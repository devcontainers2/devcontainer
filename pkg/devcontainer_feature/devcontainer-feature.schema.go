// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package devcontainer_feature

import "encoding/json"
import "fmt"
import "reflect"

type Feature struct {
	// Passes docker capabilities to include when creating the dev container.
	CapAdd []string `json:"capAdd,omitempty" yaml:"capAdd,omitempty" mapstructure:"capAdd,omitempty"`

	// Container environment variables.
	ContainerEnv FeatureContainerEnv `json:"containerEnv,omitempty" yaml:"containerEnv,omitempty" mapstructure:"containerEnv,omitempty"`

	// Tool-specific configuration. Each tool should use a JSON object subproperty
	// with a unique name to group its customizations.
	Customizations FeatureCustomizations `json:"customizations,omitempty" yaml:"customizations,omitempty" mapstructure:"customizations,omitempty"`

	// Indicates that the Feature is deprecated, and will not receive any further
	// updates/support. This property is intended to be used by the supporting tools
	// for highlighting Feature deprecation.
	Deprecated *bool `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// Description of the Feature. For the best appearance in an implementing tool,
	// refrain from including markdown or HTML in the description.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// URL to documentation for the Feature.
	DocumentationURL *string `json:"documentationURL,omitempty" yaml:"documentationURL,omitempty" mapstructure:"documentationURL,omitempty"`

	// Entrypoint script that should fire at container start up.
	Entrypoint *string `json:"entrypoint,omitempty" yaml:"entrypoint,omitempty" mapstructure:"entrypoint,omitempty"`

	// ID of the Feature. The id should be unique in the context of the
	// repository/published package where the feature exists and must match the name
	// of the directory where the devcontainer-feature.json resides.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Adds the tiny init process to the container (--init) when the Feature is used.
	Init *bool `json:"init,omitempty" yaml:"init,omitempty" mapstructure:"init,omitempty"`

	// Array of ID's of Features that should execute before this one. Allows control
	// for feature authors on soft dependencies between different Features.
	InstallsAfter []string `json:"installsAfter,omitempty" yaml:"installsAfter,omitempty" mapstructure:"installsAfter,omitempty"`

	// Array of old IDs used to publish this Feature. The property is useful for
	// renaming a currently published Feature within a single namespace.
	LegacyIds []string `json:"legacyIds,omitempty" yaml:"legacyIds,omitempty" mapstructure:"legacyIds,omitempty"`

	// URL to the license for the Feature.
	LicenseURL *string `json:"licenseURL,omitempty" yaml:"licenseURL,omitempty" mapstructure:"licenseURL,omitempty"`

	// Mounts a volume or bind mount into the container.
	Mounts []FeatureMountsElem `json:"mounts,omitempty" yaml:"mounts,omitempty" mapstructure:"mounts,omitempty"`

	// Display name of the Feature.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// A command to run when creating the container. This command is run after
	// "initializeCommand" and before "updateContentCommand". If this is a single
	// string, it will be run in a shell. If this is an array of strings, it will be
	// run as a single command without shell. If this is an object, each provided
	// command will be run in parallel.
	OnCreateCommand interface{} `json:"onCreateCommand,omitempty" yaml:"onCreateCommand,omitempty" mapstructure:"onCreateCommand,omitempty"`

	// Possible user-configurable options for this Feature. The selected options will
	// be passed as environment variables when installing the Feature into the
	// container.
	Options FeatureOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// A command to run when attaching to the container. This command is run after
	// "postStartCommand". If this is a single string, it will be run in a shell. If
	// this is an array of strings, it will be run as a single command without shell.
	// If this is an object, each provided command will be run in parallel.
	PostAttachCommand interface{} `json:"postAttachCommand,omitempty" yaml:"postAttachCommand,omitempty" mapstructure:"postAttachCommand,omitempty"`

	// A command to run after creating the container. This command is run after
	// "updateContentCommand" and before "postStartCommand". If this is a single
	// string, it will be run in a shell. If this is an array of strings, it will be
	// run as a single command without shell. If this is an object, each provided
	// command will be run in parallel.
	PostCreateCommand interface{} `json:"postCreateCommand,omitempty" yaml:"postCreateCommand,omitempty" mapstructure:"postCreateCommand,omitempty"`

	// A command to run after starting the container. This command is run after
	// "postCreateCommand" and before "postAttachCommand". If this is a single string,
	// it will be run in a shell. If this is an array of strings, it will be run as a
	// single command without shell. If this is an object, each provided command will
	// be run in parallel.
	PostStartCommand interface{} `json:"postStartCommand,omitempty" yaml:"postStartCommand,omitempty" mapstructure:"postStartCommand,omitempty"`

	// Sets privileged mode (--privileged) for the container.
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// Sets container security options to include when creating the container.
	SecurityOpt []string `json:"securityOpt,omitempty" yaml:"securityOpt,omitempty" mapstructure:"securityOpt,omitempty"`

	// A command to run when creating the container and rerun when the workspace
	// content was updated while creating the container. This command is run after
	// "onCreateCommand" and before "postCreateCommand". If this is a single string,
	// it will be run in a shell. If this is an array of strings, it will be run as a
	// single command without shell. If this is an object, each provided command will
	// be run in parallel.
	UpdateContentCommand interface{} `json:"updateContentCommand,omitempty" yaml:"updateContentCommand,omitempty" mapstructure:"updateContentCommand,omitempty"`

	// The version of the Feature. Follows the semanatic versioning (semver)
	// specification.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// Container environment variables.
type FeatureContainerEnv map[string]string

// Tool-specific configuration. Each tool should use a JSON object subproperty with
// a unique name to group its customizations.
type FeatureCustomizations map[string]interface{}

// Mounts a volume or bind mount into the container.
type FeatureMountsElem struct {
	// Mount source.
	Source string `json:"source" yaml:"source" mapstructure:"source"`

	// Mount target.
	Target string `json:"target" yaml:"target" mapstructure:"target"`

	// Type of mount. Can be 'bind' or 'volume'.
	Type FeatureMountsElemType `json:"type" yaml:"type" mapstructure:"type"`
}

type FeatureMountsElemType string

const FeatureMountsElemTypeBind FeatureMountsElemType = "bind"
const FeatureMountsElemTypeVolume FeatureMountsElemType = "volume"

type FeatureOption interface{}

// Possible user-configurable options for this Feature. The selected options will
// be passed as environment variables when installing the Feature into the
// container.
type FeatureOptions map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FeatureMountsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in FeatureMountsElem: required")
	}
	if v, ok := raw["target"]; !ok || v == nil {
		return fmt.Errorf("field target in FeatureMountsElem: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in FeatureMountsElem: required")
	}
	type Plain FeatureMountsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FeatureMountsElem(plain)
	return nil
}

var enumValues_FeatureMountsElemType = []interface{}{
	"bind",
	"volume",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Feature) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in Feature: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in Feature: required")
	}
	type Plain Feature
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Feature(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FeatureMountsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FeatureMountsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FeatureMountsElemType, v)
	}
	*j = FeatureMountsElemType(v)
	return nil
}

type MountType string

var enumValues_MountType = []interface{}{
	"bind",
	"volume",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MountType, v)
	}
	*j = MountType(v)
	return nil
}

// Mounts a volume or bind mount into the container.
type Mount struct {
	// Mount source.
	Source string `json:"source" yaml:"source" mapstructure:"source"`

	// Mount target.
	Target string `json:"target" yaml:"target" mapstructure:"target"`

	// Type of mount. Can be 'bind' or 'volume'.
	Type MountType `json:"type" yaml:"type" mapstructure:"type"`
}

const MountTypeBind MountType = "bind"
const MountTypeVolume MountType = "volume"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mount) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in Mount: required")
	}
	if v, ok := raw["target"]; !ok || v == nil {
		return fmt.Errorf("field target in Mount: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Mount: required")
	}
	type Plain Mount
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mount(plain)
	return nil
}
